TEST FAILED
Passed Assertions: 205
Failed Assertions: 395
--SUB TEST 1: 
	(2) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(3) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(4) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(6) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 15
--SUB TEST 2: 
	(8) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(9) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(10) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(12) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 2
--SUB TEST 3: 
	(14) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(15) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(16) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(18) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 16
--SUB TEST 4: 
	(20) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(21) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(22) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(24) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 8
--SUB TEST 5: 
	(26) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(27) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(28) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(30) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 16
--SUB TEST 6: 
	(32) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(33) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(34) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(36) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 19
--SUB TEST 7: 
	(38) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(39) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(40) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(42) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 19
--SUB TEST 8: 
	(44) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(45) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(46) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(48) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 12
--SUB TEST 9: 
	(50) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(51) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(52) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(54) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 26
--SUB TEST 10: 
	(56) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(57) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(58) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(60) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 24
--SUB TEST 11: 
	(62) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(63) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(64) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(66) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 8
--SUB TEST 12: 
	(68) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(69) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(70) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(72) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 20
--SUB TEST 13: 
	(74) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(75) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(76) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(78) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 24
--SUB TEST 14: 
	(80) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(81) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(82) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(84) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 7
--SUB TEST 15: 
	(86) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(87) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(88) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(90) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 25
--SUB TEST 16: 
	(92) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(93) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(94) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(96) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 10
--SUB TEST 17: 
	(98) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(99) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(100) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(102) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 17
--SUB TEST 18: 
	(104) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(105) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(106) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(108) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 9
--SUB TEST 19: 
	(110) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(111) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(112) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(114) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 5
--SUB TEST 20: 
	(116) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(117) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(118) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(120) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 21
--SUB TEST 21: 
	(122) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(123) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(124) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(126) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 16
--SUB TEST 22: 
	(128) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(129) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(130) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(132) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 5
--SUB TEST 23: 
	(134) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(135) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(136) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(138) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 23
--SUB TEST 24: 
	(140) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(141) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(142) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(144) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 25
--SUB TEST 25: 
	(146) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(147) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(148) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(150) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 8
--SUB TEST 26: 
	(152) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(153) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(154) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(156) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 18
--SUB TEST 27: 
	(158) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(159) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(160) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(162) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 10
--SUB TEST 28: 
	(164) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(165) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(166) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(168) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 18
--SUB TEST 29: 
	(170) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(171) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(172) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(174) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 5
--SUB TEST 30: 
	(176) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(177) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(178) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(180) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 4
--SUB TEST 31: 
	(182) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(183) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(184) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(186) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 22
--SUB TEST 32: 
	(188) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(189) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(190) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(192) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 19
--SUB TEST 33: 
	(194) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(195) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(196) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(198) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 23
--SUB TEST 34: 
	(200) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(201) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(202) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(204) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 11
--SUB TEST 35: 
	(206) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(207) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(208) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
--SUB TEST 36: 
	(212) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(213) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(214) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(216) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 18
--SUB TEST 37: 
	(218) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(219) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(220) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(222) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 21
--SUB TEST 38: 
	(224) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(225) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(226) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(228) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 7
--SUB TEST 39: 
	(230) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(231) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(232) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(234) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 10
--SUB TEST 40: 
	(236) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(237) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(238) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
--SUB TEST 41: 
	(242) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(243) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(244) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(246) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 3
--SUB TEST 42: 
	(248) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(249) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(250) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(252) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 14
--SUB TEST 43: 
	(254) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(255) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(256) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(258) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 0
--SUB TEST 44: 
	(260) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(261) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(262) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(264) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 4
--SUB TEST 45: 
	(266) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(267) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(268) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(270) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 19
--SUB TEST 46: 
	(272) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(273) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(274) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(276) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 19
--SUB TEST 47: 
	(278) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(279) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(280) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
--SUB TEST 48: 
	(284) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(285) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(286) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(288) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 21
--SUB TEST 49: 
	(290) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(291) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(292) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(294) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 23
--SUB TEST 50: 
	(296) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(297) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(298) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(300) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 17
--SUB TEST 51: 
	(302) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(303) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(304) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(306) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 14
--SUB TEST 52: 
	(308) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(309) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(310) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
--SUB TEST 53: 
	(314) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(315) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(316) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(318) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 25
--SUB TEST 54: 
	(320) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(321) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(322) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(324) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 0
--SUB TEST 55: 
	(326) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(327) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(328) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(330) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 6
--SUB TEST 56: 
	(332) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(333) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(334) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(336) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 0
--SUB TEST 57: 
	(338) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(339) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(340) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(342) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 12
--SUB TEST 58: 
	(344) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(345) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(346) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(348) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 22
--SUB TEST 59: 
	(350) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(351) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(352) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(354) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 2
--SUB TEST 60: 
	(356) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(357) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(358) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(360) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 24
--SUB TEST 61: 
	(362) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(363) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(364) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(366) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 10
--SUB TEST 62: 
	(368) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(369) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(370) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(372) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 22
--SUB TEST 63: 
	(374) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(375) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(376) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(378) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 1
--SUB TEST 64: 
	(380) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(381) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(382) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(384) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 25
--SUB TEST 65: 
	(386) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(387) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(388) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(390) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 20
--SUB TEST 66: 
	(392) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(393) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(394) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(396) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 9
--SUB TEST 67: 
	(398) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(399) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(400) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(402) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 26
--SUB TEST 68: 
	(404) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(405) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(406) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(408) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 1
--SUB TEST 69: 
	(410) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(411) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(412) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(414) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 8
--SUB TEST 70: 
	(416) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(417) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(418) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(420) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 6
--SUB TEST 71: 
	(422) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(423) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(424) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(426) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 24
--SUB TEST 72: 
	(428) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(429) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(430) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(432) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 5
--SUB TEST 73: 
	(434) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(435) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(436) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(438) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 7
--SUB TEST 74: 
	(440) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(441) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(442) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(444) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 3
--SUB TEST 75: 
	(446) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(447) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(448) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(450) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 1
--SUB TEST 76: 
	(452) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(453) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(454) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(456) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 12
--SUB TEST 77: 
	(458) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(459) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(460) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(462) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 14
--SUB TEST 78: 
	(464) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(465) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(466) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(468) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 26
--SUB TEST 79: 
	(470) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(471) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(472) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(474) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 2
--SUB TEST 80: 
	(476) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(477) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(478) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(480) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 21
--SUB TEST 81: 
	(482) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(483) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(484) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(486) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 15
--SUB TEST 82: 
	(488) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(489) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(490) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(492) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 7
--SUB TEST 83: 
	(494) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(495) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(496) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(498) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 23
--SUB TEST 84: 
	(500) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(501) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(502) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(504) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 7
--SUB TEST 85: 
	(506) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(507) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(508) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(510) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 4
--SUB TEST 86: 
	(512) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(513) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(514) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(516) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 1
--SUB TEST 87: 
	(518) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(519) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(520) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
--SUB TEST 88: 
	(524) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(525) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(526) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(528) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 1
--SUB TEST 89: 
	(530) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(531) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(532) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(534) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 3
--SUB TEST 90: 
	(536) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(537) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(538) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(540) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 16
--SUB TEST 91: 
	(542) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(543) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(544) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(546) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 8
--SUB TEST 92: 
	(548) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(549) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(550) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(552) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 15
--SUB TEST 93: 
	(554) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(555) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(556) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(558) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 22
--SUB TEST 94: 
	(560) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(561) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(562) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(564) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 12
--SUB TEST 95: 
	(566) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(567) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(568) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(570) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 3
--SUB TEST 96: 
	(572) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(573) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(574) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(576) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 1
--SUB TEST 97: 
	(578) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(579) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(580) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(582) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 10
--SUB TEST 98: 
	(584) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(585) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(586) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(588) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 25
--SUB TEST 99: 
	(590) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(591) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(592) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(594) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 5
--SUB TEST 100: 
	(596) FAILED*: Net change of number of cards in hand, Expected: 2, Actual: 4
	(597) FAILED*: Number of cards added to discard, Expected: 1, Actual: 0
	(598) FAILED*: Number of cards removed from deck, Expected: 3, Actual: 4
	(600) FAILED*: Top card of discard (13 == smithy), Expected: 13, Actual: 15
File 'dominion.c'
Lines executed:8.41% of 535
Creating 'dominion.c.gcov'

        -:    0:Source:dominion.c
        -:    0:Graph:dominion.gcno
        -:    0:Data:dominion.gcda
        -:    0:Runs:5
        -:    0:Programs:4
        -:    1:#include "dominion.h"
        -:    2:#include "cardEffects.h"
        -:    3:#include "dominion_helpers.h"
        -:    4:#include "rngs.h"
        -:    5:#include <math.h>
        -:    6:#include <stdio.h>
        -:    7:#include <stdlib.h>
        -:    8:
    19117:    9:int compare(const void *a, const void *b)
        -:   10:{
    19117:   11:	if (*(int *)a > *(int *)b)
     9311:   12:		return 1;
     9806:   13:	if (*(int *)a < *(int *)b)
     3459:   14:		return -1;
     6347:   15:	return 0;
        -:   16:}
        -:   17:
    #####:   18:struct gameState *newGame()
        -:   19:{
    #####:   20:	struct gameState *g = malloc(sizeof(struct gameState));
    #####:   21:	return g;
        -:   22:}
        -:   23:
    #####:   24:int *kingdomCards(int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8, int k9, int k10)
        -:   25:{
    #####:   26:	int *k = malloc(10 * sizeof(int));
    #####:   27:	k[0] = k1;
    #####:   28:	k[1] = k2;
    #####:   29:	k[2] = k3;
    #####:   30:	k[3] = k4;
    #####:   31:	k[4] = k5;
    #####:   32:	k[5] = k6;
    #####:   33:	k[6] = k7;
    #####:   34:	k[7] = k8;
    #####:   35:	k[8] = k9;
    #####:   36:	k[9] = k10;
    #####:   37:	return k;
        -:   38:}
        -:   39:
    #####:   40:int initializeGame(int numPlayers, int kingdomCards[10], int randomSeed, struct gameState *state)
        -:   41:{
        -:   42:
        -:   43:	int i;
        -:   44:	int j;
        -:   45:	int it;
        -:   46:	// set up random number generator
    #####:   47:	SelectStream(1);
    #####:   48:	PutSeed((long)randomSeed);
        -:   49:
        -:   50:	// check number of players
    #####:   51:	if (numPlayers > MAX_PLAYERS || numPlayers < 2)
        -:   52:	{
    #####:   53:		return -1;
        -:   54:	}
        -:   55:
        -:   56:	// set number of players
    #####:   57:	state->numPlayers = numPlayers;
        -:   58:
        -:   59:	// check selected kingdom cards are different
    #####:   60:	for (i = 0; i < 10; i++)
        -:   61:	{
    #####:   62:		for (j = 0; j < 10; j++)
        -:   63:		{
    #####:   64:			if (j != i && kingdomCards[j] == kingdomCards[i])
        -:   65:			{
    #####:   66:				return -1;
        -:   67:			}
        -:   68:		}
        -:   69:	}
        -:   70:
        -:   71:	// initialize supply
        -:   72:	///////////////////////////////
        -:   73:
        -:   74:	// set number of Curse cards
    #####:   75:	if (numPlayers == 2)
        -:   76:	{
    #####:   77:		state->supplyCount[curse] = 10;
        -:   78:	}
    #####:   79:	else if (numPlayers == 3)
        -:   80:	{
    #####:   81:		state->supplyCount[curse] = 20;
        -:   82:	}
        -:   83:	else
        -:   84:	{
    #####:   85:		state->supplyCount[curse] = 30;
        -:   86:	}
        -:   87:
        -:   88:	// set number of Victory cards
    #####:   89:	if (numPlayers == 2)
        -:   90:	{
    #####:   91:		state->supplyCount[estate] = 8;
    #####:   92:		state->supplyCount[duchy] = 8;
    #####:   93:		state->supplyCount[province] = 8;
        -:   94:	}
        -:   95:	else
        -:   96:	{
    #####:   97:		state->supplyCount[estate] = 12;
    #####:   98:		state->supplyCount[duchy] = 12;
    #####:   99:		state->supplyCount[province] = 12;
        -:  100:	}
        -:  101:
        -:  102:	// set number of Treasure cards
    #####:  103:	state->supplyCount[copper] = 60 - (7 * numPlayers);
    #####:  104:	state->supplyCount[silver] = 40;
    #####:  105:	state->supplyCount[gold] = 30;
        -:  106:
        -:  107:	// set number of Kingdom cards
    #####:  108:	for (i = adventurer; i <= treasure_map; i++) // loop all cards
        -:  109:	{
    #####:  110:		for (j = 0; j < 10; j++) // loop chosen cards
        -:  111:		{
    #####:  112:			if (kingdomCards[j] == i)
        -:  113:			{
        -:  114:				// check if card is a 'Victory' Kingdom card
    #####:  115:				if (kingdomCards[j] == great_hall || kingdomCards[j] == gardens)
        -:  116:				{
    #####:  117:					if (numPlayers == 2)
        -:  118:					{
    #####:  119:						state->supplyCount[i] = 8;
        -:  120:					}
        -:  121:					else
        -:  122:					{
    #####:  123:						state->supplyCount[i] = 12;
        -:  124:					}
        -:  125:				}
        -:  126:				else
        -:  127:				{
    #####:  128:					state->supplyCount[i] = 10;
        -:  129:				}
    #####:  130:				break;
        -:  131:			}
        -:  132:			else // card is not in the set choosen for the game
        -:  133:			{
    #####:  134:				state->supplyCount[i] = -1;
        -:  135:			}
        -:  136:		}
        -:  137:	}
        -:  138:
        -:  139:	////////////////////////
        -:  140:	// supply intilization complete
        -:  141:
        -:  142:	// set player decks
    #####:  143:	for (i = 0; i < numPlayers; i++)
        -:  144:	{
    #####:  145:		state->deckCount[i] = 0;
    #####:  146:		for (j = 0; j < 3; j++)
        -:  147:		{
    #####:  148:			state->deck[i][j] = estate;
    #####:  149:			state->deckCount[i]++;
        -:  150:		}
    #####:  151:		for (j = 3; j < 10; j++)
        -:  152:		{
    #####:  153:			state->deck[i][j] = copper;
    #####:  154:			state->deckCount[i]++;
        -:  155:		}
        -:  156:	}
        -:  157:
        -:  158:	// shuffle player decks
    #####:  159:	for (i = 0; i < numPlayers; i++)
        -:  160:	{
    #####:  161:		if (shuffle(i, state) < 0)
        -:  162:		{
    #####:  163:			return -1;
        -:  164:		}
        -:  165:	}
        -:  166:
        -:  167:	// draw player hands
    #####:  168:	for (i = 0; i < numPlayers; i++)
        -:  169:	{
        -:  170:		// initialize hand size to zero
    #####:  171:		state->handCount[i] = 0;
    #####:  172:		state->discardCount[i] = 0;
        -:  173:		// draw 5 cards
        -:  174:		// for (j = 0; j < 5; j++)
        -:  175:		//	{
        -:  176:		//	  drawCard(i, state);
        -:  177:		//	}
        -:  178:	}
        -:  179:
        -:  180:	// set embargo tokens to 0 for all supply piles
    #####:  181:	for (i = 0; i <= treasure_map; i++)
        -:  182:	{
    #####:  183:		state->embargoTokens[i] = 0;
        -:  184:	}
        -:  185:
        -:  186:	// initialize first player's turn
    #####:  187:	state->outpostPlayed = 0;
    #####:  188:	state->phase = 0;
    #####:  189:	state->numActions = 1;
    #####:  190:	state->numBuys = 1;
    #####:  191:	state->playedCardCount = 0;
    #####:  192:	state->whoseTurn = 0;
    #####:  193:	state->handCount[state->whoseTurn] = 0;
        -:  194:	// int it; move to top
        -:  195:
        -:  196:	// Moved draw cards to here, only drawing at the start of a turn
    #####:  197:	for (it = 0; it < 5; it++)
        -:  198:	{
    #####:  199:		drawCard(state->whoseTurn, state);
        -:  200:	}
        -:  201:
    #####:  202:	updateCoins(state->whoseTurn, state, 0);
        -:  203:
    #####:  204:	return 0;
        -:  205:}
        -:  206:
       24:  207:int shuffle(int player, struct gameState *state)
        -:  208:{
        -:  209:
        -:  210:	int newDeck[MAX_DECK];
       24:  211:	int newDeckPos = 0;
        -:  212:	int card;
        -:  213:	int i;
        -:  214:
       24:  215:	if (state->deckCount[player] < 1)
       13:  216:		return -1;
       11:  217:	qsort((void *)(state->deck[player]), state->deckCount[player], sizeof(int), compare);
        -:  218:	/* SORT CARDS IN DECK TO ENSURE DETERMINISM! */
        -:  219:
     2765:  220:	while (state->deckCount[player] > 0)
        -:  221:	{
     2743:  222:		card = floor(Random() * state->deckCount[player]);
     2743:  223:		newDeck[newDeckPos] = state->deck[player][card];
     2743:  224:		newDeckPos++;
   245590:  225:		for (i = card; i < state->deckCount[player] - 1; i++)
        -:  226:		{
   242847:  227:			state->deck[player][i] = state->deck[player][i + 1];
        -:  228:		}
     2743:  229:		state->deckCount[player]--;
        -:  230:	}
     2754:  231:	for (i = 0; i < newDeckPos; i++)
        -:  232:	{
     2743:  233:		state->deck[player][i] = newDeck[i];
     2743:  234:		state->deckCount[player]++;
        -:  235:	}
        -:  236:
       11:  237:	return 0;
        -:  238:}
        -:  239:
    #####:  240:int playCard(int handPos, int choice1, int choice2, int choice3, struct gameState *state)
        -:  241:{
        -:  242:	int card;
    #####:  243:	int coin_bonus = 0; // tracks coins gain from actions
        -:  244:
        -:  245:	// check if it is the right phase
    #####:  246:	if (state->phase != 0)
        -:  247:	{
    #####:  248:		return -1;
        -:  249:	}
        -:  250:
        -:  251:	// check if player has enough actions
    #####:  252:	if (state->numActions < 1)
        -:  253:	{
    #####:  254:		return -1;
        -:  255:	}
        -:  256:
        -:  257:	// get card played
    #####:  258:	card = handCard(handPos, state);
        -:  259:
        -:  260:	// check if selected card is an action
    #####:  261:	if (card < adventurer || card > treasure_map)
        -:  262:	{
    #####:  263:		return -1;
        -:  264:	}
        -:  265:
        -:  266:	// play card
    #####:  267:	if (cardEffect(card, choice1, choice2, choice3, state, handPos, &coin_bonus) < 0)
        -:  268:	{
    #####:  269:		return -1;
        -:  270:	}
        -:  271:
        -:  272:	// reduce number of actions
    #####:  273:	state->numActions--;
        -:  274:
        -:  275:	// update coins (Treasure cards may be added with card draws)
    #####:  276:	updateCoins(state->whoseTurn, state, coin_bonus);
        -:  277:
    #####:  278:	return 0;
        -:  279:}
        -:  280:
    #####:  281:int buyCard(int supplyPos, struct gameState *state)
        -:  282:{
        -:  283:	int who;
        -:  284:	if (DEBUG)
        -:  285:	{
        -:  286:		printf("Entering buyCard...\n");
        -:  287:	}
        -:  288:
        -:  289:	// I don't know what to do about the phase thing.
        -:  290:
    #####:  291:	who = state->whoseTurn;
        -:  292:
    #####:  293:	if (state->numBuys < 1)
        -:  294:	{
        -:  295:		if (DEBUG)
        -:  296:			printf("You do not have any buys left\n");
    #####:  297:		return -1;
        -:  298:	}
    #####:  299:	else if (supplyCount(supplyPos, state) < 1)
        -:  300:	{
        -:  301:		if (DEBUG)
        -:  302:			printf("There are not any of that type of card left\n");
    #####:  303:		return -1;
        -:  304:	}
    #####:  305:	else if (state->coins < getCost(supplyPos))
        -:  306:	{
        -:  307:		if (DEBUG)
        -:  308:			printf("You do not have enough money to buy that. You have %d coins.\n", state->coins);
    #####:  309:		return -1;
        -:  310:	}
        -:  311:	else
        -:  312:	{
    #####:  313:		state->phase = 1;
        -:  314:		// state->supplyCount[supplyPos]--;
    #####:  315:		gainCard(supplyPos, state, 0, who); // card goes in discard, this might be wrong.. (2 means
        -:  316:											// goes into hand, 0 goes into discard)
        -:  317:
    #####:  318:		state->coins = (state->coins) - (getCost(supplyPos));
    #####:  319:		state->numBuys--;
        -:  320:		if (DEBUG)
        -:  321:			printf("You bought card number %d for %d coins. You now have %d buys and %d coins.\n",
        -:  322:				   supplyPos, getCost(supplyPos), state->numBuys, state->coins);
        -:  323:	}
        -:  324:
        -:  325:	// state->discard[who][state->discardCount[who]] = supplyPos;
        -:  326:	// state->discardCount[who]++;
        -:  327:
    #####:  328:	return 0;
        -:  329:}
        -:  330:
    #####:  331:int numHandCards(struct gameState *state) { return state->handCount[whoseTurn(state)]; }
        -:  332:
    #####:  333:int handCard(int handPos, struct gameState *state)
        -:  334:{
    #####:  335:	int currentPlayer = whoseTurn(state);
    #####:  336:	return state->hand[currentPlayer][handPos];
        -:  337:}
        -:  338:
    #####:  339:int supplyCount(int card, struct gameState *state) { return state->supplyCount[card]; }
        -:  340:
    #####:  341:int fullDeckCount(int player, int card, struct gameState *state)
        -:  342:{
        -:  343:	int i;
    #####:  344:	int count = 0;
        -:  345:
    #####:  346:	for (i = 0; i < state->deckCount[player]; i++)
        -:  347:	{
    #####:  348:		if (state->deck[player][i] == card)
    #####:  349:			count++;
        -:  350:	}
        -:  351:
    #####:  352:	for (i = 0; i < state->handCount[player]; i++)
        -:  353:	{
    #####:  354:		if (state->hand[player][i] == card)
    #####:  355:			count++;
        -:  356:	}
        -:  357:
    #####:  358:	for (i = 0; i < state->discardCount[player]; i++)
        -:  359:	{
    #####:  360:		if (state->discard[player][i] == card)
    #####:  361:			count++;
        -:  362:	}
        -:  363:
    #####:  364:	return count;
        -:  365:}
        -:  366:
      500:  367:int whoseTurn(struct gameState *state) { return state->whoseTurn; }
        -:  368:
    #####:  369:int endTurn(struct gameState *state)
        -:  370:{
        -:  371:	int k;
        -:  372:	int i;
    #####:  373:	int currentPlayer = whoseTurn(state);
        -:  374:
        -:  375:	// Discard hand
    #####:  376:	for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  377:	{
    #####:  378:		state->discard[currentPlayer][state->discardCount[currentPlayer]++] =
    #####:  379:			state->hand[currentPlayer][i];  // Discard
    #####:  380:		state->hand[currentPlayer][i] = -1; // Set card to -1
        -:  381:	}
    #####:  382:	state->handCount[currentPlayer] = 0; // Reset hand count
        -:  383:
        -:  384:	// Code for determining the player
    #####:  385:	if (currentPlayer < (state->numPlayers - 1))
        -:  386:	{
    #####:  387:		state->whoseTurn = currentPlayer + 1; // Still safe to increment
        -:  388:	}
        -:  389:	else
        -:  390:	{
    #####:  391:		state->whoseTurn = 0; // Max player has been reached, loop back around to player 1
        -:  392:	}
        -:  393:
    #####:  394:	state->outpostPlayed = 0;
    #####:  395:	state->phase = 0;
    #####:  396:	state->numActions = 1;
    #####:  397:	state->coins = 0;
    #####:  398:	state->numBuys = 1;
    #####:  399:	state->playedCardCount = 0;
    #####:  400:	state->handCount[state->whoseTurn] = 0;
        -:  401:
        -:  402:	// int k; move to top
        -:  403:	// Next player draws hand
    #####:  404:	for (k = 0; k < 5; k++)
        -:  405:	{
    #####:  406:		drawCard(state->whoseTurn, state); // Draw a card
        -:  407:	}
        -:  408:
        -:  409:	// Update money
    #####:  410:	updateCoins(state->whoseTurn, state, 0);
        -:  411:
    #####:  412:	return 0;
        -:  413:}
        -:  414:
    #####:  415:int isGameOver(struct gameState *state)
        -:  416:{
        -:  417:	int i;
        -:  418:	int j;
        -:  419:
        -:  420:	// if stack of Province cards is empty, the game ends
    #####:  421:	if (state->supplyCount[province] == 0)
        -:  422:	{
    #####:  423:		return 1;
        -:  424:	}
        -:  425:
        -:  426:	// if three supply pile are at 0, the game ends
    #####:  427:	j = 0;
    #####:  428:	for (i = 0; i < 25; i++)
        -:  429:	{
    #####:  430:		if (state->supplyCount[i] == 0)
        -:  431:		{
    #####:  432:			j++;
        -:  433:		}
        -:  434:	}
    #####:  435:	if (j >= 3)
        -:  436:	{
    #####:  437:		return 1;
        -:  438:	}
        -:  439:
    #####:  440:	return 0;
        -:  441:}
        -:  442:
    #####:  443:int scoreFor(int player, struct gameState *state)
        -:  444:{
        -:  445:
        -:  446:	int i;
    #####:  447:	int score = 0;
        -:  448:	// score from hand
    #####:  449:	for (i = 0; i < state->handCount[player]; i++)
        -:  450:	{
    #####:  451:		if (state->hand[player][i] == curse)
        -:  452:		{
    #####:  453:			score = score - 1;
        -:  454:		};
    #####:  455:		if (state->hand[player][i] == estate)
        -:  456:		{
    #####:  457:			score = score + 1;
        -:  458:		};
    #####:  459:		if (state->hand[player][i] == duchy)
        -:  460:		{
    #####:  461:			score = score + 3;
        -:  462:		};
    #####:  463:		if (state->hand[player][i] == province)
        -:  464:		{
    #####:  465:			score = score + 6;
        -:  466:		};
    #####:  467:		if (state->hand[player][i] == great_hall)
        -:  468:		{
    #####:  469:			score = score + 1;
        -:  470:		};
    #####:  471:		if (state->hand[player][i] == gardens)
        -:  472:		{
    #####:  473:			score = score + (fullDeckCount(player, 0, state) / 10);
        -:  474:		};
        -:  475:	}
        -:  476:
        -:  477:	// score from discard
    #####:  478:	for (i = 0; i < state->discardCount[player]; i++)
        -:  479:	{
    #####:  480:		if (state->discard[player][i] == curse)
        -:  481:		{
    #####:  482:			score = score - 1;
        -:  483:		};
    #####:  484:		if (state->discard[player][i] == estate)
        -:  485:		{
    #####:  486:			score = score + 1;
        -:  487:		};
    #####:  488:		if (state->discard[player][i] == duchy)
        -:  489:		{
    #####:  490:			score = score + 3;
        -:  491:		};
    #####:  492:		if (state->discard[player][i] == province)
        -:  493:		{
    #####:  494:			score = score + 6;
        -:  495:		};
    #####:  496:		if (state->discard[player][i] == great_hall)
        -:  497:		{
    #####:  498:			score = score + 1;
        -:  499:		};
    #####:  500:		if (state->discard[player][i] == gardens)
        -:  501:		{
    #####:  502:			score = score + (fullDeckCount(player, 0, state) / 10);
        -:  503:		};
        -:  504:	}
        -:  505:
        -:  506:	// score from deck
    #####:  507:	for (i = 0; i < state->discardCount[player]; i++)
        -:  508:	{
    #####:  509:		if (state->deck[player][i] == curse)
        -:  510:		{
    #####:  511:			score = score - 1;
        -:  512:		};
    #####:  513:		if (state->deck[player][i] == estate)
        -:  514:		{
    #####:  515:			score = score + 1;
        -:  516:		};
    #####:  517:		if (state->deck[player][i] == duchy)
        -:  518:		{
    #####:  519:			score = score + 3;
        -:  520:		};
    #####:  521:		if (state->deck[player][i] == province)
        -:  522:		{
    #####:  523:			score = score + 6;
        -:  524:		};
    #####:  525:		if (state->deck[player][i] == great_hall)
        -:  526:		{
    #####:  527:			score = score + 1;
        -:  528:		};
    #####:  529:		if (state->deck[player][i] == gardens)
        -:  530:		{
    #####:  531:			score = score + (fullDeckCount(player, 0, state) / 10);
        -:  532:		};
        -:  533:	}
        -:  534:
    #####:  535:	return score;
        -:  536:}
        -:  537:
    #####:  538:int getWinners(int players[MAX_PLAYERS], struct gameState *state)
        -:  539:{
        -:  540:	int i;
        -:  541:	int j;
        -:  542:	int highScore;
        -:  543:	int currentPlayer;
        -:  544:
        -:  545:	// get score for each player
    #####:  546:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  547:	{
        -:  548:		// set unused player scores to -9999
    #####:  549:		if (i >= state->numPlayers)
        -:  550:		{
    #####:  551:			players[i] = -9999;
        -:  552:		}
        -:  553:		else
        -:  554:		{
    #####:  555:			players[i] = scoreFor(i, state);
        -:  556:		}
        -:  557:	}
        -:  558:
        -:  559:	// find highest score
    #####:  560:	j = 0;
    #####:  561:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  562:	{
    #####:  563:		if (players[i] > players[j])
        -:  564:		{
    #####:  565:			j = i;
        -:  566:		}
        -:  567:	}
    #####:  568:	highScore = players[j];
        -:  569:
        -:  570:	// add 1 to players who had less turns
    #####:  571:	currentPlayer = whoseTurn(state);
    #####:  572:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  573:	{
    #####:  574:		if (players[i] == highScore && i > currentPlayer)
        -:  575:		{
    #####:  576:			players[i]++;
        -:  577:		}
        -:  578:	}
        -:  579:
        -:  580:	// find new highest score
    #####:  581:	j = 0;
    #####:  582:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  583:	{
    #####:  584:		if (players[i] > players[j])
        -:  585:		{
    #####:  586:			j = i;
        -:  587:		}
        -:  588:	}
    #####:  589:	highScore = players[j];
        -:  590:
        -:  591:	// set winners in array to 1 and rest to 0
    #####:  592:	for (i = 0; i < MAX_PLAYERS; i++)
        -:  593:	{
    #####:  594:		if (players[i] == highScore)
        -:  595:		{
    #####:  596:			players[i] = 1;
        -:  597:		}
        -:  598:		else
        -:  599:		{
    #####:  600:			players[i] = 0;
        -:  601:		}
        -:  602:	}
        -:  603:
    #####:  604:	return 0;
        -:  605:}
        -:  606:
     6193:  607:int drawCard(int player, struct gameState *state)
        -:  608:{
        -:  609:	int count;
        -:  610:	int deckCounter;
     6193:  611:	if (state->deckCount[player] <= 0)
        -:  612:	{ // Deck is empty
        -:  613:
        -:  614:		// Step 1 Shuffle the discard pile back into a deck
        -:  615:		int i;
        -:  616:		// Move discard to deck
     2755:  617:		for (i = 0; i < state->discardCount[player]; i++)
        -:  618:		{
     2743:  619:			state->deck[player][i] = state->discard[player][i];
     2743:  620:			state->discard[player][i] = -1;
        -:  621:		}
        -:  622:
       12:  623:		state->deckCount[player] = state->discardCount[player];
       12:  624:		state->discardCount[player] = 0; // Reset discard
        -:  625:
        -:  626:		// Shufffle the deck
       12:  627:		shuffle(player, state); // Shuffle the deck up and make it so that we can draw
        -:  628:
        -:  629:		if (DEBUG)
        -:  630:		{ // Debug statements
        -:  631:			printf("Deck count now: %d\n", state->deckCount[player]);
        -:  632:		}
        -:  633:
       12:  634:		state->discardCount[player] = 0;
        -:  635:
        -:  636:		// Step 2 Draw Card
       12:  637:		count = state->handCount[player]; // Get current player's hand count
        -:  638:
        -:  639:		if (DEBUG)
        -:  640:		{ // Debug statements
        -:  641:			printf("Current hand count: %d\n", count);
        -:  642:		}
        -:  643:
       12:  644:		deckCounter = state->deckCount[player]; // Create a holder for the deck count
        -:  645:
       12:  646:		if (deckCounter == 0)
        1:  647:			return -1;
        -:  648:
       11:  649:		state->hand[player][count] = state->deck[player][deckCounter - 1]; // Add card to hand
       11:  650:		state->deckCount[player]--;
       11:  651:		state->handCount[player]++; // Increment hand count
        -:  652:	}
        -:  653:
        -:  654:	else
        -:  655:	{
     6181:  656:		int count = state->handCount[player]; // Get current hand count for player
        -:  657:		int deckCounter;
        -:  658:		if (DEBUG)
        -:  659:		{ // Debug statements
        -:  660:			printf("Current hand count: %d\n", count);
        -:  661:		}
        -:  662:
     6181:  663:		deckCounter = state->deckCount[player]; // Create holder for the deck count
     6181:  664:		state->hand[player][count] = state->deck[player][deckCounter - 1]; // Add card to the hand
     6181:  665:		state->deckCount[player]--;
     6181:  666:		state->handCount[player]++; // Increment hand count
        -:  667:	}
        -:  668:
     6192:  669:	return 0;
        -:  670:}
        -:  671:
    #####:  672:int getCost(int cardNumber)
        -:  673:{
    #####:  674:	switch (cardNumber)
        -:  675:	{
        -:  676:	case curse:
    #####:  677:		return 0;
        -:  678:	case estate:
    #####:  679:		return 2;
        -:  680:	case duchy:
    #####:  681:		return 5;
        -:  682:	case province:
    #####:  683:		return 8;
        -:  684:	case copper:
    #####:  685:		return 0;
        -:  686:	case silver:
    #####:  687:		return 3;
        -:  688:	case gold:
    #####:  689:		return 6;
        -:  690:	case adventurer:
    #####:  691:		return 6;
        -:  692:	case council_room:
    #####:  693:		return 5;
        -:  694:	case feast:
    #####:  695:		return 4;
        -:  696:	case gardens:
    #####:  697:		return 4;
        -:  698:	case mine:
    #####:  699:		return 5;
        -:  700:	case remodel:
    #####:  701:		return 4;
        -:  702:	case smithy:
    #####:  703:		return 4;
        -:  704:	case village:
    #####:  705:		return 3;
        -:  706:	case baron:
    #####:  707:		return 4;
        -:  708:	case great_hall:
    #####:  709:		return 3;
        -:  710:	case minion:
    #####:  711:		return 5;
        -:  712:	case steward:
    #####:  713:		return 3;
        -:  714:	case tribute:
    #####:  715:		return 5;
        -:  716:	case ambassador:
    #####:  717:		return 3;
        -:  718:	case cutpurse:
    #####:  719:		return 4;
        -:  720:	case embargo:
    #####:  721:		return 2;
        -:  722:	case outpost:
    #####:  723:		return 5;
        -:  724:	case salvager:
    #####:  725:		return 4;
        -:  726:	case sea_hag:
    #####:  727:		return 4;
        -:  728:	case treasure_map:
    #####:  729:		return 4;
        -:  730:	}
        -:  731:
    #####:  732:	return -1;
        -:  733:}
        -:  734:
    #####:  735:int cardEffect(int card, int choice1, int choice2, int choice3, struct gameState *state,
        -:  736:			   int handPos, int *bonus)
        -:  737:{
        -:  738:	int i;
        -:  739:	int j;
        -:  740:	int k;
        -:  741:	int index;
    #####:  742:	int currentPlayer = whoseTurn(state);
    #####:  743:	int nextPlayer = currentPlayer + 1;
        -:  744:
    #####:  745:	int tributeRevealedCards[2] = {-1, -1};
    #####:  746:	if (nextPlayer > (state->numPlayers - 1))
        -:  747:	{
    #####:  748:		nextPlayer = 0;
        -:  749:	}
        -:  750:
        -:  751:	// uses switch to select card and perform actions
    #####:  752:	switch (card)
        -:  753:	{
        -:  754:	case adventurer:
    #####:  755:		return cardEffect_Adventurer(state);
        -:  756:
        -:  757:	case council_room:
        -:  758:		//+4 Cards
    #####:  759:		for (i = 0; i < 4; i++)
        -:  760:		{
    #####:  761:			drawCard(currentPlayer, state);
        -:  762:		}
        -:  763:
        -:  764:		//+1 Buy
    #####:  765:		state->numBuys++;
        -:  766:
        -:  767:		// Each other player draws a card
    #####:  768:		for (i = 0; i < state->numPlayers; i++)
        -:  769:		{
    #####:  770:			if (i != currentPlayer)
        -:  771:			{
    #####:  772:				drawCard(i, state);
        -:  773:			}
        -:  774:		}
        -:  775:
        -:  776:		// put played card in played card pile
    #####:  777:		discardCard(handPos, currentPlayer, state, 0);
        -:  778:
    #####:  779:		return 0;
        -:  780:
        -:  781:	case feast:
    #####:  782:		return cardEffect_Feast(state, choice1);
        -:  783:
        -:  784:	case gardens:
    #####:  785:		return cardEffect_Gardens(state);
        -:  786:
        -:  787:	case mine:
    #####:  788:		j = state->hand[currentPlayer][choice1]; // store card we will trash
        -:  789:
    #####:  790:		if (state->hand[currentPlayer][choice1] < copper ||
    #####:  791:			state->hand[currentPlayer][choice1] > gold)
        -:  792:		{
    #####:  793:			return -1;
        -:  794:		}
        -:  795:
    #####:  796:		if (choice2 > treasure_map || choice2 < curse)
        -:  797:		{
    #####:  798:			return -1;
        -:  799:		}
        -:  800:
    #####:  801:		if ((getCost(state->hand[currentPlayer][choice1]) + 3) > getCost(choice2))
        -:  802:		{
    #####:  803:			return -1;
        -:  804:		}
        -:  805:
    #####:  806:		gainCard(choice2, state, 2, currentPlayer);
        -:  807:
        -:  808:		// discard card from hand
    #####:  809:		discardCard(handPos, currentPlayer, state, 0);
        -:  810:
        -:  811:		// discard trashed card
    #####:  812:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  813:		{
    #####:  814:			if (state->hand[currentPlayer][i] == j)
        -:  815:			{
    #####:  816:				discardCard(i, currentPlayer, state, 0);
    #####:  817:				break;
        -:  818:			}
        -:  819:		}
        -:  820:
    #####:  821:		return 0;
        -:  822:
        -:  823:	case remodel:
    #####:  824:		j = state->hand[currentPlayer][choice1]; // store card we will trash
        -:  825:
    #####:  826:		if ((getCost(state->hand[currentPlayer][choice1]) + 2) > getCost(choice2))
        -:  827:		{
    #####:  828:			return -1;
        -:  829:		}
        -:  830:
    #####:  831:		gainCard(choice2, state, 0, currentPlayer);
        -:  832:
        -:  833:		// discard card from hand
    #####:  834:		discardCard(handPos, currentPlayer, state, 0);
        -:  835:
        -:  836:		// discard trashed card
    #####:  837:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -:  838:		{
    #####:  839:			if (state->hand[currentPlayer][i] == j)
        -:  840:			{
    #####:  841:				discardCard(i, currentPlayer, state, 0);
    #####:  842:				break;
        -:  843:			}
        -:  844:		}
        -:  845:
    #####:  846:		return 0;
        -:  847:
        -:  848:	case smithy:
    #####:  849:		return cardEffect_Smithy(state, handPos);
        -:  850:
        -:  851:	case village:
        -:  852:		//+1 Card
    #####:  853:		drawCard(currentPlayer, state);
        -:  854:
        -:  855:		//+2 Actions
    #####:  856:		state->numActions = state->numActions + 2;
        -:  857:
        -:  858:		// discard played card from hand
    #####:  859:		discardCard(handPos, currentPlayer, state, 0);
    #####:  860:		return 0;
        -:  861:
        -:  862:	case baron:
    #####:  863:		state->numBuys++; // Increase buys by 1!
    #####:  864:		if (choice1 > 0)
        -:  865:		{								// Boolean true or going to discard an estate
    #####:  866:			int p = 0;					// Iterator for hand!
    #####:  867:			int card_not_discarded = 1; // Flag for discard set!
    #####:  868:			while (card_not_discarded)
        -:  869:			{
    #####:  870:				if (state->hand[currentPlayer][p] == estate)
        -:  871:				{					   // Found an estate card!
    #####:  872:					state->coins += 4; // Add 4 coins to the amount of coins
    #####:  873:					state->discard[currentPlayer][state->discardCount[currentPlayer]] =
    #####:  874:						state->hand[currentPlayer][p];
    #####:  875:					state->discardCount[currentPlayer]++;
    #####:  876:					for (; p < state->handCount[currentPlayer]; p++)
        -:  877:					{
    #####:  878:						state->hand[currentPlayer][p] = state->hand[currentPlayer][p + 1];
        -:  879:					}
    #####:  880:					state->hand[currentPlayer][state->handCount[currentPlayer]] = -1;
    #####:  881:					state->handCount[currentPlayer]--;
    #####:  882:					card_not_discarded = 0; // Exit the loop
        -:  883:				}
    #####:  884:				else if (p > state->handCount[currentPlayer])
        -:  885:				{
        -:  886:					if (DEBUG)
        -:  887:					{
        -:  888:						printf("No estate cards in your hand, invalid choice\n");
        -:  889:						printf("Must gain an estate if there are any\n");
        -:  890:					}
    #####:  891:					if (supplyCount(estate, state) > 0)
        -:  892:					{
    #####:  893:						gainCard(estate, state, 0, currentPlayer);
    #####:  894:						state->supplyCount[estate]--; // Decrement estates
    #####:  895:						if (supplyCount(estate, state) == 0)
        -:  896:						{
    #####:  897:							isGameOver(state);
        -:  898:						}
        -:  899:					}
    #####:  900:					card_not_discarded = 0; // Exit the loop
        -:  901:				}
        -:  902:
        -:  903:				else
        -:  904:				{
    #####:  905:					p++; // Next card
        -:  906:				}
        -:  907:			}
        -:  908:		}
        -:  909:
        -:  910:		else
        -:  911:		{
    #####:  912:			if (supplyCount(estate, state) > 0)
        -:  913:			{
    #####:  914:				gainCard(estate, state, 0, currentPlayer); // Gain an estate
    #####:  915:				state->supplyCount[estate]--;			   // Decrement Estates
    #####:  916:				if (supplyCount(estate, state) == 0)
        -:  917:				{
    #####:  918:					isGameOver(state);
        -:  919:				}
        -:  920:			}
        -:  921:		}
        -:  922:
    #####:  923:		return 0;
        -:  924:
        -:  925:	case great_hall:
        -:  926:		//+1 Card
    #####:  927:		drawCard(currentPlayer, state);
        -:  928:
        -:  929:		//+1 Actions
    #####:  930:		state->numActions++;
        -:  931:
        -:  932:		// discard card from hand
    #####:  933:		discardCard(handPos, currentPlayer, state, 0);
    #####:  934:		return 0;
        -:  935:
        -:  936:	case minion:
        -:  937:		//+1 action
    #####:  938:		state->numActions++;
        -:  939:
        -:  940:		// discard card from hand
    #####:  941:		discardCard(handPos, currentPlayer, state, 0);
        -:  942:
    #####:  943:		if (choice1) //+2 coins
        -:  944:		{
    #####:  945:			state->coins = state->coins + 2;
        -:  946:		}
        -:  947:
    #####:  948:		else if (choice2) // discard hand, redraw 4, other players with 5+ cards discard hand and
        -:  949:						  // draw 4
        -:  950:		{
        -:  951:			// discard hand
    #####:  952:			while (numHandCards(state) > 0)
        -:  953:			{
    #####:  954:				discardCard(handPos, currentPlayer, state, 0);
        -:  955:			}
        -:  956:
        -:  957:			// draw 4
    #####:  958:			for (i = 0; i < 4; i++)
        -:  959:			{
    #####:  960:				drawCard(currentPlayer, state);
        -:  961:			}
        -:  962:
        -:  963:			// other players discard hand and redraw if hand size > 4
    #####:  964:			for (i = 0; i < state->numPlayers; i++)
        -:  965:			{
    #####:  966:				if (i != currentPlayer)
        -:  967:				{
    #####:  968:					if (state->handCount[i] > 4)
        -:  969:					{
        -:  970:						// discard hand
    #####:  971:						while (state->handCount[i] > 0)
        -:  972:						{
    #####:  973:							discardCard(handPos, i, state, 0);
        -:  974:						}
        -:  975:
        -:  976:						// draw 4
    #####:  977:						for (j = 0; j < 4; j++)
        -:  978:						{
    #####:  979:							drawCard(i, state);
        -:  980:						}
        -:  981:					}
        -:  982:				}
        -:  983:			}
        -:  984:		}
    #####:  985:		return 0;
        -:  986:
        -:  987:	case steward:
    #####:  988:		return cardEffect_Steward(state, handPos, choice1, choice2, choice3);
        -:  989:
        -:  990:	case tribute:
    #####:  991:		if ((state->discardCount[nextPlayer] + state->deckCount[nextPlayer]) <= 1)
        -:  992:		{
    #####:  993:			if (state->deckCount[nextPlayer] > 0)
        -:  994:			{
    #####:  995:				tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####:  996:				state->deckCount[nextPlayer]--;
        -:  997:			}
    #####:  998:			else if (state->discardCount[nextPlayer] > 0)
        -:  999:			{
    #####: 1000:				tributeRevealedCards[0] =
    #####: 1001:					state->discard[nextPlayer][state->discardCount[nextPlayer] - 1];
    #####: 1002:				state->discardCount[nextPlayer]--;
        -: 1003:			}
        -: 1004:			else
        -: 1005:			{
        -: 1006:				// No Card to Reveal
        -: 1007:				if (DEBUG)
        -: 1008:				{
        -: 1009:					printf("No cards to reveal\n");
        -: 1010:				}
        -: 1011:			}
        -: 1012:		}
        -: 1013:
        -: 1014:		else
        -: 1015:		{
    #####: 1016:			if (state->deckCount[nextPlayer] == 0)
        -: 1017:			{
    #####: 1018:				for (i = 0; i < state->discardCount[nextPlayer]; i++)
        -: 1019:				{
    #####: 1020:					state->deck[nextPlayer][i] = state->discard[nextPlayer][i]; // Move to deck
    #####: 1021:					state->deckCount[nextPlayer]++;
    #####: 1022:					state->discard[nextPlayer][i] = -1;
    #####: 1023:					state->discardCount[nextPlayer]--;
        -: 1024:				}
        -: 1025:
    #####: 1026:				shuffle(nextPlayer, state); // Shuffle the deck
        -: 1027:			}
    #####: 1028:			tributeRevealedCards[0] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1029:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1030:			state->deckCount[nextPlayer]--;
    #####: 1031:			tributeRevealedCards[1] = state->deck[nextPlayer][state->deckCount[nextPlayer] - 1];
    #####: 1032:			state->deck[nextPlayer][state->deckCount[nextPlayer]--] = -1;
    #####: 1033:			state->deckCount[nextPlayer]--;
        -: 1034:		}
        -: 1035:
    #####: 1036:		if (tributeRevealedCards[0] == tributeRevealedCards[1])
        -: 1037:		{ // If we have a duplicate card, just drop one
    #####: 1038:			state->playedCards[state->playedCardCount] = tributeRevealedCards[1];
    #####: 1039:			state->playedCardCount++;
    #####: 1040:			tributeRevealedCards[1] = -1;
        -: 1041:		}
        -: 1042:
    #####: 1043:		for (i = 0; i <= 2; i++)
        -: 1044:		{
    #####: 1045:			if (tributeRevealedCards[i] == copper || tributeRevealedCards[i] == silver ||
    #####: 1046:				tributeRevealedCards[i] == gold)
        -: 1047:			{ // Treasure cards
    #####: 1048:				state->coins += 2;
        -: 1049:			}
        -: 1050:
    #####: 1051:			else if (tributeRevealedCards[i] == estate || tributeRevealedCards[i] == duchy ||
    #####: 1052:					 tributeRevealedCards[i] == province || tributeRevealedCards[i] == gardens ||
    #####: 1053:					 tributeRevealedCards[i] == great_hall)
        -: 1054:			{ // Victory Card Found
    #####: 1055:				drawCard(currentPlayer, state);
    #####: 1056:				drawCard(currentPlayer, state);
        -: 1057:			}
        -: 1058:			else
        -: 1059:			{ // Action Card
    #####: 1060:				state->numActions = state->numActions + 2;
        -: 1061:			}
        -: 1062:		}
        -: 1063:
    #####: 1064:		return 0;
        -: 1065:
        -: 1066:	case ambassador:
    #####: 1067:		j = 0; // used to check if player has enough cards to discard
        -: 1068:
    #####: 1069:		if (choice2 > 2 || choice2 < 0)
        -: 1070:		{
    #####: 1071:			return -1;
        -: 1072:		}
        -: 1073:
    #####: 1074:		if (choice1 == handPos)
        -: 1075:		{
    #####: 1076:			return -1;
        -: 1077:		}
        -: 1078:
    #####: 1079:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1080:		{
    #####: 1081:			if (i != handPos && i == state->hand[currentPlayer][choice1] && i != choice1)
        -: 1082:			{
    #####: 1083:				j++;
        -: 1084:			}
        -: 1085:		}
    #####: 1086:		if (j < choice2)
        -: 1087:		{
    #####: 1088:			return -1;
        -: 1089:		}
        -: 1090:
        -: 1091:		if (DEBUG)
        -: 1092:			printf("Player %d reveals card number: %d\n", currentPlayer,
        -: 1093:				   state->hand[currentPlayer][choice1]);
        -: 1094:
        -: 1095:		// increase supply count for choosen card by amount being discarded
    #####: 1096:		state->supplyCount[state->hand[currentPlayer][choice1]] += choice2;
        -: 1097:
        -: 1098:		// each other player gains a copy of revealed card
    #####: 1099:		for (i = 0; i < state->numPlayers; i++)
        -: 1100:		{
    #####: 1101:			if (i != currentPlayer)
        -: 1102:			{
    #####: 1103:				gainCard(state->hand[currentPlayer][choice1], state, 0, i);
        -: 1104:			}
        -: 1105:		}
        -: 1106:
        -: 1107:		// discard played card from hand
    #####: 1108:		discardCard(handPos, currentPlayer, state, 0);
        -: 1109:
        -: 1110:		// trash copies of cards returned to supply
    #####: 1111:		for (j = 0; j < choice2; j++)
        -: 1112:		{
    #####: 1113:			for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1114:			{
    #####: 1115:				if (state->hand[currentPlayer][i] == state->hand[currentPlayer][choice1])
        -: 1116:				{
    #####: 1117:					discardCard(i, currentPlayer, state, 1);
    #####: 1118:					break;
        -: 1119:				}
        -: 1120:			}
        -: 1121:		}
        -: 1122:
    #####: 1123:		return 0;
        -: 1124:
        -: 1125:	case cutpurse:
        -: 1126:
    #####: 1127:		updateCoins(currentPlayer, state, 2);
    #####: 1128:		for (i = 0; i < state->numPlayers; i++)
        -: 1129:		{
    #####: 1130:			if (i != currentPlayer)
        -: 1131:			{
    #####: 1132:				for (j = 0; j < state->handCount[i]; j++)
        -: 1133:				{
    #####: 1134:					if (state->hand[i][j] == copper)
        -: 1135:					{
    #####: 1136:						discardCard(j, i, state, 0);
    #####: 1137:						break;
        -: 1138:					}
    #####: 1139:					if (j == state->handCount[i])
        -: 1140:					{
    #####: 1141:						for (k = 0; k < state->handCount[i]; k++)
        -: 1142:						{
        -: 1143:							if (DEBUG)
        -: 1144:								printf("Player %d reveals card number %d\n", i, state->hand[i][k]);
        -: 1145:						}
    #####: 1146:						break;
        -: 1147:					}
        -: 1148:				}
        -: 1149:			}
        -: 1150:		}
        -: 1151:
        -: 1152:		// discard played card from hand
    #####: 1153:		discardCard(handPos, currentPlayer, state, 0);
        -: 1154:
    #####: 1155:		return 0;
        -: 1156:
        -: 1157:	case embargo:
        -: 1158:		//+2 Coins
    #####: 1159:		state->coins = state->coins + 2;
        -: 1160:
        -: 1161:		// see if selected pile is in play
    #####: 1162:		if (state->supplyCount[choice1] == -1)
        -: 1163:		{
    #####: 1164:			return -1;
        -: 1165:		}
        -: 1166:
        -: 1167:		// add embargo token to selected supply pile
    #####: 1168:		state->embargoTokens[choice1]++;
        -: 1169:
        -: 1170:		// trash card
    #####: 1171:		discardCard(handPos, currentPlayer, state, 1);
    #####: 1172:		return 0;
        -: 1173:
        -: 1174:	case outpost:
        -: 1175:		// set outpost flag
    #####: 1176:		state->outpostPlayed++;
        -: 1177:
        -: 1178:		// discard card
    #####: 1179:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1180:		return 0;
        -: 1181:
        -: 1182:	case salvager:
        -: 1183:		//+1 buy
    #####: 1184:		state->numBuys++;
        -: 1185:
    #####: 1186:		if (choice1)
        -: 1187:		{
        -: 1188:			// gain coins equal to trashed card
    #####: 1189:			state->coins = state->coins + getCost(handCard(choice1, state));
        -: 1190:			// trash card
    #####: 1191:			discardCard(choice1, currentPlayer, state, 1);
        -: 1192:		}
        -: 1193:
        -: 1194:		// discard card
    #####: 1195:		discardCard(handPos, currentPlayer, state, 0);
    #####: 1196:		return 0;
        -: 1197:
        -: 1198:	case sea_hag:
    #####: 1199:		for (i = 0; i < state->numPlayers; i++)
        -: 1200:		{
    #####: 1201:			if (i != currentPlayer)
        -: 1202:			{
    #####: 1203:				state->discard[i][state->discardCount[i]] = state->deck[i][state->deckCount[i]--];
    #####: 1204:				state->deckCount[i]--;
    #####: 1205:				state->discardCount[i]++;
    #####: 1206:				state->deck[i][state->deckCount[i]--] = curse; // Top card now a curse
        -: 1207:			}
        -: 1208:		}
    #####: 1209:		return 0;
        -: 1210:
        -: 1211:	case treasure_map:
        -: 1212:		// search hand for another treasure_map
    #####: 1213:		index = -1;
    #####: 1214:		for (i = 0; i < state->handCount[currentPlayer]; i++)
        -: 1215:		{
    #####: 1216:			if (state->hand[currentPlayer][i] == treasure_map && i != handPos)
        -: 1217:			{
    #####: 1218:				index = i;
    #####: 1219:				break;
        -: 1220:			}
        -: 1221:		}
    #####: 1222:		if (index > -1)
        -: 1223:		{
        -: 1224:			// trash both treasure cards
    #####: 1225:			discardCard(handPos, currentPlayer, state, 1);
    #####: 1226:			discardCard(index, currentPlayer, state, 1);
        -: 1227:
        -: 1228:			// gain 4 Gold cards
    #####: 1229:			for (i = 0; i < 4; i++)
        -: 1230:			{
    #####: 1231:				gainCard(gold, state, 1, currentPlayer);
        -: 1232:			}
        -: 1233:
        -: 1234:			// return success
    #####: 1235:			return 1;
        -: 1236:		}
        -: 1237:
        -: 1238:		// no second treasure_map found in hand
    #####: 1239:		return -1;
        -: 1240:	}
        -: 1241:
    #####: 1242:	return -1;
        -: 1243:}
        -: 1244:
    #####: 1245:int discardCard(int handPos, int currentPlayer, struct gameState *state, int trashFlag)
        -: 1246:{
        -: 1247:
        -: 1248:	// if card is not trashed, added to Played pile
    #####: 1249:	if (trashFlag < 1)
        -: 1250:	{
        -: 1251:		// add card to played pile
    #####: 1252:		state->playedCards[state->playedCardCount] = state->hand[currentPlayer][handPos];
    #####: 1253:		state->playedCardCount++;
        -: 1254:	}
        -: 1255:
        -: 1256:	// set played card to -1
    #####: 1257:	state->hand[currentPlayer][handPos] = -1;
        -: 1258:
        -: 1259:	// remove card from player's hand
    #####: 1260:	if (handPos == (state->handCount[currentPlayer] - 1)) // last card in hand array is played
        -: 1261:	{
        -: 1262:		// reduce number of cards in hand
    #####: 1263:		state->handCount[currentPlayer]--;
        -: 1264:	}
    #####: 1265:	else if (state->handCount[currentPlayer] == 1) // only one card in hand
        -: 1266:	{
        -: 1267:		// reduce number of cards in hand
    #####: 1268:		state->handCount[currentPlayer]--;
        -: 1269:	}
        -: 1270:	else
        -: 1271:	{
        -: 1272:		// replace discarded card with last card in hand
    #####: 1273:		state->hand[currentPlayer][handPos] =
    #####: 1274:			state->hand[currentPlayer][(state->handCount[currentPlayer] - 1)];
        -: 1275:		// set last card to -1
    #####: 1276:		state->hand[currentPlayer][state->handCount[currentPlayer] - 1] = -1;
        -: 1277:		// reduce number of cards in hand
    #####: 1278:		state->handCount[currentPlayer]--;
        -: 1279:	}
        -: 1280:
    #####: 1281:	return 0;
        -: 1282:}
        -: 1283:
    #####: 1284:int gainCard(int supplyPos, struct gameState *state, int toFlag, int player)
        -: 1285:{
        -: 1286:	// Note: supplyPos is enum of choosen card
        -: 1287:
        -: 1288:	// check if supply pile is empty (0) or card is not used in game (-1)
    #####: 1289:	if (supplyCount(supplyPos, state) < 1)
        -: 1290:	{
    #####: 1291:		return -1;
        -: 1292:	}
        -: 1293:
        -: 1294:	// added card for [whoseTurn] current player:
        -: 1295:	// toFlag = 0 : add to discard
        -: 1296:	// toFlag = 1 : add to deck
        -: 1297:	// toFlag = 2 : add to hand
        -: 1298:
    #####: 1299:	if (toFlag == 1)
        -: 1300:	{
    #####: 1301:		state->deck[player][state->deckCount[player]] = supplyPos;
    #####: 1302:		state->deckCount[player]++;
        -: 1303:	}
    #####: 1304:	else if (toFlag == 2)
        -: 1305:	{
    #####: 1306:		state->hand[player][state->handCount[player]] = supplyPos;
    #####: 1307:		state->handCount[player]++;
        -: 1308:	}
        -: 1309:	else
        -: 1310:	{
    #####: 1311:		state->discard[player][state->discardCount[player]] = supplyPos;
    #####: 1312:		state->discardCount[player]++;
        -: 1313:	}
        -: 1314:
        -: 1315:	// decrease number in supply pile
    #####: 1316:	state->supplyCount[supplyPos]--;
        -: 1317:
    #####: 1318:	return 0;
        -: 1319:}
        -: 1320:
    #####: 1321:int updateCoins(int player, struct gameState *state, int bonus)
        -: 1322:{
        -: 1323:	int i;
        -: 1324:
        -: 1325:	// reset coin count
    #####: 1326:	state->coins = 0;
        -: 1327:
        -: 1328:	// add coins for each Treasure card in player's hand
    #####: 1329:	for (i = 0; i < state->handCount[player]; i++)
        -: 1330:	{
    #####: 1331:		if (state->hand[player][i] == copper)
        -: 1332:		{
    #####: 1333:			state->coins += 1;
        -: 1334:		}
    #####: 1335:		else if (state->hand[player][i] == silver)
        -: 1336:		{
    #####: 1337:			state->coins += 2;
        -: 1338:		}
    #####: 1339:		else if (state->hand[player][i] == gold)
        -: 1340:		{
    #####: 1341:			state->coins += 3;
        -: 1342:		}
        -: 1343:	}
        -: 1344:
        -: 1345:	// add bonus
    #####: 1346:	state->coins += bonus;
        -: 1347:
    #####: 1348:	return 0;
        -: 1349:}
        -: 1350:
        -: 1351:// end of dominion.c
